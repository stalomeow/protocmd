package main

import (
	"flag"
	"fmt"
	"google.golang.org/protobuf/reflect/protoreflect"
	"path"
	"strings"
)

type csharpGenerator struct {
	allTypeFullNames    []string
	baseNamespace       string
	hasBaseNamespace    bool
	msgHelpersClassName string
	msgHelpersClassNs   string
}

func init() {
	registerLangGenerator(&csharpGenerator{})
}

func (*csharpGenerator) langName() string {
	return "csharp"
}

func (gen *csharpGenerator) initGenerator(context *generateContext) error {
	gen.allTypeFullNames = make([]string, 0)
	gen.baseNamespace, gen.hasBaseNamespace = context.popArg("base_namespace")

	flags := flag.FlagSet{}
	flags.StringVar(&gen.msgHelpersClassName, "msg_helpers_name", "MessageHelpers", "")
	if gen.hasBaseNamespace {
		flags.StringVar(&gen.msgHelpersClassNs, "msg_helpers_ns", gen.baseNamespace, "")
	} else {
		flags.StringVar(&gen.msgHelpersClassNs, "msg_helpers_ns", "", "")
	}
	return context.writeArgsToFlagSet(&flags)
}

func (gen *csharpGenerator) generate(context *generateContext) error {
	err := gen.initGenerator(context)
	if err != nil {
		return err
	}

	files, err := context.filterFilesToGenerate()
	if err != nil {
		return err
	}

	for _, f := range files {
		gf := genFile{}

		gen.writeFileHeader(f, &gf)
		gf.println("using pb = global::Google.Protobuf;")
		gf.println()

		ns := getCSharpFileNamespace(f)
		if ns != "" {
			gf.println("namespace ", ns)
			gf.println("{")
			gf.indent(1)
		}

		prevTypeCount := len(gen.allTypeFullNames)
		gen.writeMsg(context, f.Messages(), &gf, ns)
		if len(gen.allTypeFullNames) <= prevTypeCount {
			continue
		}

		if ns != "" {
			gf.indent(-1)
			gf.println("}")
		}

		filename, err := gen.convertToCSharpFileNameWithoutExt(ns, f.Path())
		if err != nil {
			return err
		}
		context.addGenFile(filename+".cmd.cs", &gf)
	}

	err = gen.writeMsgHelpersClass(context)
	return err
}

func (*csharpGenerator) writeFileHeader(srcFile protoreflect.FileDescriptor, gf *genFile) {
	gf.println("// <auto-generated>")
	gf.println("//     Generated by protoc-gen-cmd v", genVersion, ".  DO NOT EDIT!")
	if srcFile != nil {
		gf.println("//     source: ", srcFile.Path())
	}
	gf.println("// </auto-generated>")
	gf.println()
}

func (gen *csharpGenerator) writeMsg(context *generateContext, messages protoreflect.MessageDescriptors, gf *genFile, ns string) {
	for i := 0; i < messages.Len(); i++ {
		msg := messages.Get(i)

		cmdId, ok := context.config.CmdIdMap[string(msg.FullName())]
		if !ok {
			continue
		}

		cmdName := string(msg.Name())
		typeFullName := cmdName
		if ns != "" {
			typeFullName = ns + "." + typeFullName
		}
		gen.allTypeFullNames = append(gen.allTypeFullNames, typeFullName)

		gf.println("partial class ", cmdName, " : pb::ICmdMessage")
		gf.println("{")
		gf.indent(1)
		gf.println("public static ushort CmdId { get { return ", cmdId, "; } }")
		gf.println("ushort pb::ICmdMessage.CmdId { get { return ", cmdId, "; } }")
		gf.println()
		gf.println("public static string CmdName { get { return \"", cmdName, "\"; } }")
		gf.println("string pb::ICmdMessage.CmdName { get { return \"", cmdName, "\"; } }")

		if nestedMessages := msg.Messages(); nestedMessages.Len() > 0 {
			gf.println()
			gf.println("partial class Types")
			gf.println("{")
			gf.indent(1)

			gen.writeMsg(context, nestedMessages, gf, typeFullName+".Types")

			gf.indent(-1)
			gf.println("}")
		}

		gf.indent(-1)
		gf.println("}")
	}
}

func (gen *csharpGenerator) writeMsgHelpersClass(context *generateContext) error {
	if len(gen.allTypeFullNames) <= 0 {
		return nil
	}

	gf := genFile{}
	gen.writeFileHeader(nil, &gf)
	gf.println("using pb = global::Google.Protobuf;")
	gf.println()

	if gen.msgHelpersClassNs != "" {
		gf.println("namespace ", gen.msgHelpersClassNs)
		gf.println("{")
		gf.indent(1)
	}

	gf.println("public partial class ", gen.msgHelpersClassName, " : pb::BaseMessageHelpers")
	gf.println("{")
	gf.indent(1)

	gf.println("public ", gen.msgHelpersClassName, "()")
	gf.println("{")
	gf.indent(1)

	for _, t := range gen.allTypeFullNames {
		gf.println("this.Register(", t, ".CmdId, ", t, ".CmdName, ", t, ".Parser, () => ", t, ".Descriptor);")
	}

	gf.indent(-1)
	gf.println("}")
	gf.indent(-1)
	gf.println("}")

	if gen.msgHelpersClassNs != "" {
		gf.indent(-1)
		gf.println("}")
	}

	filename, err := gen.convertToCSharpFileNameWithoutExt(gen.msgHelpersClassNs, gen.msgHelpersClassName)
	if err != nil {
		return err
	}
	context.addGenFile(filename+".cs", &gf)
	return nil
}

func (gen *csharpGenerator) convertToCSharpFileNameWithoutExt(ns string, filename string) (string, error) {
	filename = strings.TrimSuffix(filename, path.Ext(filename))
	filename = underscoresToCamelCase(filename, true, true)

	if !gen.hasBaseNamespace {
		return filename, nil
	}

	nsSuffix := ns

	if gen.baseNamespace != "" {
		// Check that the base_namespace is either equal to or a leading part of
		// the file namespace. This isn't just a simple prefix; "Foo.B" shouldn't
		// be regarded as a prefix of "Foo.Bar". The simplest option is to add "."
		// to both.
		suffix, found := strings.CutPrefix(ns, gen.baseNamespace)
		if !found || (suffix != "" && !strings.HasPrefix(suffix, ".")) {
			return "", fmt.Errorf("namespace %s does not have base namespace %s", ns, gen.baseNamespace)
		}

		if suffix == "" {
			nsSuffix = suffix
		} else {
			nsSuffix = suffix[1:] // trim leading period
		}
	}

	return path.Join(strings.ReplaceAll(nsSuffix, ".", "/"), filename), nil
}

func getCSharpFileNamespace(desc protoreflect.FileDescriptor) string {
	options := desc.Options().ProtoReflect()
	fields := options.Descriptor().Fields()
	for i := 0; i < fields.Len(); i++ {
		f := fields.Get(i)
		if f.Name() == "csharp_namespace" {
			if ns := options.Get(f).String(); ns != "" {
				return ns
			}
		}
	}
	return underscoresToCamelCase(string(desc.Package()), true, true)
}
